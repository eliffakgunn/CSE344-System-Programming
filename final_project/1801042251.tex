%%%%%%%%%%%%%%%%% DO NOT CHANGE HERE %%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{
    \documentclass[twoside,11pt]{article}
    %%%%% PACKAGES %%%%%%
    \usepackage{pgm2016}
    \usepackage{amsmath}
    \usepackage{algorithm}
    \usepackage[noend]{algpseudocode}
    \usepackage{subcaption}
    \usepackage[english]{babel}	
    \usepackage{paralist}	
    \usepackage[lowtilde]{url}
    \usepackage{fixltx2e}
    \usepackage{listings}
    \usepackage{color}
    \usepackage{hyperref}
    
    \usepackage{auto-pst-pdf}
    \usepackage{pst-all}
    \usepackage{pstricks-add}
    
    %%%%% MACROS %%%%%%
    \algrenewcommand\Return{\State \algorithmicreturn{} }
    \algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
    \renewcommand{\thesubfigure}{\roman{subfigure}}
    \definecolor{codegreen}{rgb}{0,0.6,0}
    \definecolor{codegray}{rgb}{0.5,0.5,0.5}
    \definecolor{codepurple}{rgb}{0.58,0,0.82}
    \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
    \lstdefinestyle{mystyle}{
       backgroundcolor=\color{backcolour},  
       commentstyle=\color{codegreen},
       keywordstyle=\color{magenta},
       numberstyle=\tiny\color{codegray},
       stringstyle=\color{codepurple},
       basicstyle=\footnotesize,
       breakatwhitespace=false,        
       breaklines=true,                
       captionpos=b,                    
       keepspaces=true,                
       numbers=left,                    
       numbersep=5pt,                  
       showspaces=false,                
       showstringspaces=false,
       showtabs=false,                  
       tabsize=2
    }
    \lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% }

%%%%%%%%%%%%%%%%%%%%%%%% CHANGE HERE %%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% {
\newcommand\course{CSE 344}
\newcommand\courseName{System Programming}
\newcommand\semester{Spring 2020}
\newcommand\studentName{Elif Akgün}                  % <-- YOUR NAME
\newcommand\studentNumber{1801042251}                % <-- STUDENT ID #
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%% DO NOT CHANGE HERE %%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%{

    \ShortHeadings{Gebze Technical University -  \course ~~ \courseName}{\studentName - \studentNumber}
    \firstpageno{1}
    
    \begin{document}
    
    \title{Final Project \assignmentNumber}
    
    \author{\name \studentName \email \studentEmail \\
    \studentNumber
    \addr
    }
    
    \maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% }

\section{Problem Definition} 
\label{sec:background}

This project includes two programs: server and client. The server which is daemon loads a graph from text file, handles incoming connections from client by using dynamic pool. Every time that the load of the server reaches 75\%, i.e. 75\% of the threads become busy, then the pool size will be enlarged by 25\%. The client(s) connect to the server and request a path between two arbitrary nodes, and the server will provide this service.\newline

\subsection{Server}

The server receives the following command line arguments: \newline
\newline
./server -i pathToFile -p PORT -o pathToLogFile -s 4 -x 24 \newline
\newline
pathToFile: denotes the relative or absolute path to an input file containing a directed unweighted graph ( from https://snap.stanford.edu/data/ ) \newline
\newline
PORT: this is the port number the server will use for incoming connections.\newline
\newline
pathToLogFile: is the relative or absolute path of the log file to which the server daemon will write all of its output (normal output & errors).\newline
\newline
s: this is the number of threads in the pool at startup (at least 2)\newline
\newline
x: this is the maximum allowed number of threads, the pool must not grow beyond this number.\newline
\newline
**BONUS** \newline
Enable the -r commandline argument of the server:\newline
r = 0 : reader prioritization \newline
r = 1 : writer prioritization \newline
r = 2 : equal priorities to readers and writers \newline
\newline
The server process communicates with the client processes through stream/TCP socket based connections. The server possess a pool of POSIX threads, and in the form of an endless loop, as soon as a new connection arrives, it will forward that new connection to an available thread of the pool, and immediately continue waiting for a new connection. If no thread is available, then it waits in a blocked status until a thread becomes available. \newline
\newline
The pool of threads created and initialized at the daemon’s startup, and each thread executes in an endless loop, first waiting for a connection to be handed to them by the server, then handling it, and then waiting again, and so on. Once a connection is established, the client sends two indexes i1 and i2, as two non negative integers, representing each one of the nodes of the graph, to the
server, and waits for the server to reply with the path from i1 to i2. Server uses BFS to find a path form i1 to 12. If the requested path from i1 to i2 has been already calculated during a past request (by the same or other thread), the thread handling this request should first check a “cache data structure”, containing past calculations, and if the requested path is present in it, the thread should simply use it to respond to the client, instead of recalculating it. If it is not present in the “cache data structure” then it must inevitably calculate it, respond to the client, and add the newly calculated path into the data structure, so as to accelerate future requests. If no path is possible between the requested nodes, then the server responds accordingly. The cache data structure is common to all threads of the pool and can be thought of as a “database”. It does not contain duplicate entries.\newline
\newline
If the server receives the SIGINT signal (through the kill command) it waits for its ongoing threads to complete, returns all allocated resources, and then shutdown gracefully. \newline

\subsection{Client}

Given the server’s address and port number, client requests a path from node i1 to i2 and wait for a response, while printing its output on the terminal.\newline
\newline
The client receives the following command line arguments: \newline
\newline
./client -a 127.0.0.1 -p PORT -s 768 -d 979 \newline
\newline
a: IP address of the machine running the server \newline
p: port number at which the server waits for connections \newline
s: source node of the requested path \newline
d: destination node of the requested path \newline

\newpage

\section{Implementation}
\label{sec:background}

\subsection{Server}

In server process, I made also bonus part. According to r's values, threads created related pool. If r is equal to 0, then threadPoolR function is used; If r is equal to 1 or -1(when r is not included in the command line), then threadPoolW function is used; and if r is equal to 2, then threadPoolRW function is used.

\subsubsection{Main}

Server become daemon with \emph{daemon\_} function and fork, setsid, umask, chrdir system calls used for this purpose.After fork parent process terminates and the child process runs in the background. To prevent double instantiation, I used \emph{createLockFile} function. To prevent double instantiation, I create a file ( \emph{lockFile}), then I locked this file. So if another instantiation of the program wants to run it, file lock prints error message.
\newline
Input file was read then the graph was loaded to memory with \emph{loadGraph} function. Then the socket and threads were created. 
\newline
In while loop, server waits for new connection. When client makes a request, server signals to thread pool to notify that a request is made. If SIGINT comes, then server break the loop and waits for threads.

\subsubsection{threadPoolW}

This pool implemented by readers/writers paradigm, by prioritizing writers. First of all, all threads wait signal(\emph{condVar}) from main thread. When a signal came, one of threads take mutex and goes on. Take accept system call's file descriptor, then sends signal (\emph{condVar2}) to main again to notify that signal is tooken. Thus, main thread waits for pool threads until one of threads takes request. So, if there is no available thread, main thread waits. Then, thread increases \emph{busyThrNum}, which keeps number of busy threads, then sends signal(\emph{condVar3}) to tracker thread to notify busy thread number was increased. Then, reads the source and destination nodes. It checks the cache, if it includes this path, thread responses to client. If it does not, it finds path with \emph{BFS} function. Actually, this function finds visited array from source node to destination node. Then \emph{absPath} function finds path from visited array. After path was found, thread responses to client and writes path to cahce. If graph does not include this path, then server sends to client -1. It means that, this path is not possible.\newline
\newline
According to readers/writers paradigm, reader threads wait if there is any writer in cache or waiting. If there no waiting writer thread or active writer thread, then reader thread can read the database. On the other hands, Writers wait if there are active reader or active writer. For readers/writers paradigm, I used \emph{m} mutex, \emph{okToRead} and \emph{okToWrite} conditional variables and \emph{AR}, \emph{AW}, \emph{WW}, \emph{WR} variables.\newline
\newline
For other synchronization problem, I used \emph{mutex},\emph{mtx}, \emph{condVar}, \emph{condvar2}, and \emph{condVar3}. Main thread also used \emph{mutex} so they run synchronously.

\subsubsection{threadPoolR}

This function same as \emph{threadPoolR}. There is one difference: this pool implemented by readers/writers paradigm, by prioritizing readers. Reader threads wait if there is any writer in cache. If there is no active writer thread, then reader threads can read the database. On the other hands, writers wait if there are active reader, active writer or waiting reader.

\subsubsection{threadPoolRW}

This function same as \emph{threadPoolW} and \emph{threadPoolR}. There is one difference: this pool implemented by readers/writers paradigm, by priorities equally. When reader thread wants read, it waits for mutex, takes mutex, read cache, then unlocks the mutex. As the same,  when writer thread wants write to cache, it waits for mutex, takes mutex, wirtes to cache, then unlocks the mutex.\newline

\subsubsection{tracker}

This thread tracks the load of pool, if it increase 75\% then enlarges it by 25\%. If load less than 75\%, it waits until load increases. If thread numbers reache maximum thread number, it does not enlarge the pool. When SIGINT came, breaks the infinite loop and waits for threads that it created.
\newline
For this synchronization problem, I used \emph{mtx} and \emph{condVar3}. When busy thread number is increase, threads send signal to tracker with \emph{condvar3}.

\subsubsection{handler}

When SIGINT came, handler handles this signal and assign 0 to \emph{isRuning} to notify other threads teminating signal has come.

\subsubsection{cache data structure}

I used 2D dynamic array for cache. Firstly its size is 1*1. As the request calculates and writes to cache, its row enlarged one by one. If new path's size is larger than cache's column size, then column resizes.

\subsection{Client}

Client process more simple than server process. It creates socket then sends to source and destination nodes, which are readed from command line. It reads server's respons and wirtes path to terminal. \newpage

\section{Tests} 
\label{sec:background}

\subsection{Sample Input/Output}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
\includegraphics[scale=0.4]{figures/1.png}
\end{tabular}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
\includegraphics[scale=0.6]{figures/2.png}
\end{tabular}
\end{center}
\end{figure}

\newpage

\subsection{Testing Command Line Arguments}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
\includegraphics[scale=0.5]{figures/3.png}
\end{tabular}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
\includegraphics[scale=0.5]{figures/12.png}
\end{tabular}
\end{center}
\end{figure}

\subsection{Testing Double Instantiation}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
\includegraphics[scale=0.8]{figures/4.png}
\end{tabular}
\end{center}
\end{figure}

\newpage

\subsection{Testing SIGINT Signal}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
\includegraphics{figures/5.png}
\end{tabular}
\end{center}
\end{figure}


\end{document}
